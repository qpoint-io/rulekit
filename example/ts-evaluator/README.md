# @qpoint/rule-evaluator

TypeScript rule evaluator for rulekit AST. This package evaluates rules exported as JSON AST from the Go rulekit library.

## Installation

```bash
npm install @qpoint/rule-evaluator
```

## Quick Start

```typescript
import { Rule } from "@qpoint/rule-evaluator";

// Parse AST from JSON (generated by Go rulekit)
const ast = {
  node_type: "operator",
  operator: "and",
  left: {
    node_type: "operator",
    operator: "eq",
    left: { node_type: "field", name: "port" },
    right: { node_type: "literal", type: "int", value: 8080 }
  },
  right: {
    node_type: "operator",
    operator: "matches",
    left: { node_type: "field", name: "method" },
    right: { node_type: "literal", type: "string", value: "^GET|POST$" }
  }
};

const rule = Rule.fromJSON(ast);

// Evaluate against data
const passes = rule.passes({ 
  port: 8080, 
  method: "GET" 
}); // true

// Get detailed result
const result = rule.eval({ 
  port: 8080, 
  method: "DELETE" 
});
console.log(result); 
// { ok: true, value: false }
```

## Features

- ✅ **Clean TypeScript** - Idiomatic code using standard patterns
- ✅ **Type-safe** - Full TypeScript type definitions
- ✅ **All operators** - Supports ==, !=, >, >=, <, <=, contains, matches, in
- ✅ **Logical operators** - and, or, not with short-circuit evaluation
- ✅ **Nested fields** - Supports dot notation (e.g., `request.headers.host`)
- ✅ **Custom functions** - Extend with your own functions
- ✅ **Arrays** - Array operations and the `in` operator
- ✅ **Error handling** - Graceful error messages for missing fields
- ✅ **Round-trip** - Convert AST back to Go-parseable text format

## Supported Operators

### Comparison
- `eq` or `==` - Equality
- `ne` or `!=` - Inequality
- `gt` or `>` - Greater than
- `ge` or `>=` - Greater than or equal
- `lt` or `<` - Less than
- `le` or `<=` - Less than or equal

### String/Array
- `contains` - String substring or array membership
- `matches` - Regular expression match
- `in` - Value in array

### Logical
- `and` - Logical AND (short-circuits)
- `or` - Logical OR (short-circuits)
- `not` - Logical NOT

## Examples

### Nested Field Access

```typescript
const rule = Rule.fromJSON({
  node_type: "operator",
  operator: "eq",
  left: { node_type: "field", name: "request.method" },
  right: { node_type: "literal", type: "string", value: "POST" }
});

rule.passes({
  request: { method: "POST" }
}); // true
```

### Array Operations

```typescript
const rule = Rule.fromJSON({
  node_type: "operator",
  operator: "in",
  left: { node_type: "field", name: "status" },
  right: {
    node_type: "array",
    elements: [
      { node_type: "literal", type: "int", value: 200 },
      { node_type: "literal", type: "int", value: 201 }
    ]
  }
});

rule.passes({ status: 200 }); // true
```

### Custom Functions

```typescript
import { Rule, cidrContains } from "@qpoint/rule-evaluator";

const rule = Rule.fromJSON({
  node_type: "function",
  name: "cidr_contains",
  args: {
    node_type: "array",
    elements: [
      { node_type: "field", name: "ip" },
      { node_type: "literal", type: "string", value: "10.0.0.0/8" }
    ]
  }
});

rule.passes(
  { ip: "10.1.2.3" },
  { cidr_contains } // Pass custom functions
); // true
```

### Error Handling

```typescript
const rule = Rule.fromJSON({
  node_type: "operator",
  operator: "eq",
  left: { node_type: "field", name: "missing" },
  right: { node_type: "literal", type: "int", value: 42 }
});

const result = rule.eval({ other: 100 });
console.log(result);
// { ok: false, value: null, error: "Missing field: missing" }
```

## Workflow: Go to TypeScript

1. **Define rule in Go**:
```go
rule := rulekit.MustParse(`port == 8080 and method =~ /^GET|POST$/`)
```

2. **Export AST as JSON**:
```go
ast := rule.ASTNode()
jsonBytes, _ := json.Marshal(ast)
```

3. **Evaluate in TypeScript**:
```typescript
const rule = Rule.fromJSON(jsonString);
const passes = rule.passes(data);
```

4. **Convert back to text (optional)**:
```typescript
const expression = rule.toString();
// "port == 8080 and method =~ /^GET|POST$/"
// Can be parsed by Go again!
```

## API Reference

### `Rule`

#### `Rule.fromJSON(json: string | object): Rule`
Parse a rule from JSON AST.

#### `rule.eval(data: Record<string, any>, functions?: Record<string, Function>): EvalResult`
Evaluate the rule and return detailed result.

#### `rule.passes(data: Record<string, any>, functions?: Record<string, Function>): boolean`
Check if rule passes (convenience method).

#### `rule.toString(): string`
Convert AST back to Go-parseable expression string. Perfect for round-tripping.

### `evaluate(node: ASTNode, ctx: Context): EvalResult`
Low-level AST evaluation function.

### `stringify(node: ASTNode, isRoot?: boolean): string`
Convert an AST node to expression string. Use `rule.toString()` instead for most cases.

### Types

See `src/types.ts` for full type definitions.

## Round-trip Testing

The package supports perfect round-trip conversion:

```bash
# 1. Export rules from Go
cd ../go-to-ts-demo && go run main.go

# 2. Convert to text in TypeScript
cd ../ts-evaluator && npm run roundtrip

# 3. Verify in Go
cd ../go-to-ts-demo && go run verify-roundtrip.go
```

This verifies:
1. Go parses expression → AST
2. AST serializes to JSON
3. TypeScript loads JSON → AST
4. TypeScript converts AST → text
5. Go parses text successfully (completes the cycle!)

## License

MIT

